---
title: "Intro To Survey Analysis"
output: html_document
---
## How to Use This Document

This is an R markdown document which creates a self-contained HTML file you can use to save your code and to create reports to share. A major benefit of R Markdowns is they are a reproducible method of your work which comes in handy for QC & testing, or if you are asked a question about your analysis 6 months after you turned it in.  

The main pieces of the Markdown files are code chunks (where you write your code) and text.  

When running our code chunks, we have a variety of options we can set:   

* `include = FALSE` prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.  
* `echo = FALS`E prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.  
* `message = FALSE` prevents messages that are generated by code from appearing in the finished file.  
* `warning = FALSE` prevents warnings that are generated by code from appearing in the finished.  
* `fig.cap = "..."` adds a caption to graphical results.  

[For text syntax, checkout this R Markdown cheatsheet](https://rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf).

# Introduction

The owner of Feline Good Cat Boutique, Hillary, has noticed a decrease in transactions and sales and wonders if there are some pain points in the customer experience that's driving the decrease.  

Our research objective:  
1. Are there aspects of the customer experiences at Good Cat Boutique Hillary should address?  

We will evaluate this research objective by answering the following business questions:  
1. What are the most important features when selecting where to shop?  
2. Of those items that are most important, how is Sassy Cat Boutique preforming (what is the satisfaction rating)?  

## Agenda

This tutorial is broken out into the following sections:  

1. Survey Data Prep
2. Creating Tidy Data
3. Creating HTML Tables
4. Creating a Banner Output

## 1. Survey Data Prep

Start by opening the project, `KSU-Intro-to-Survey-Analysis.Rproj`. This enables you to read the files directly from this folder without having to set a working directory. All files we output will be saved in this folder. 

### Load Survey Data

The pacman package is used as a package management tool and is used load packages.   

```{r setup, include=FALSE}

if (!require(pacman)) {
  install.packages('pacman')
}

#notice that you do not have to use install.packages()
pacman::p_load(stringr, plotly, ggplot2, ggthemes, readr, formattable, openxlsx, kableExtra, scales, tidyr, Hmisc, dplyr)

#use the percent option in the package scales
percent<-scales::percent

#raw survey data
survey_df <- read_csv('survey_results.csv')
#question metadata
question_df <- read_csv('question_metadata.csv')


```

We can use the function `glimpse()` to look at the raw survey data. 

```{r glimpse_survey}
glimpse(survey_df)
```

Typically surveys columns are coded such the survey question, _Please check all the items below that pertain to you and your cat. Have you ever..._, is represented by the question number and depending on the question type, the choice item number.  

In our survey dataset question `Q02_1`:  
  
* `Q02` represents the survey question; _Please check all the items below that pertain to you and your cat. Have you ever..._  
* and `_1` represents the item selection: _Celebrated your catâ€™s birthday and/or adoption date?_   

Our question metadata file has the survey coded question column and description. 

```{r glimpse_question}
glimpse(question_df)
```

Our question metadata file has the following columns:  

* question: The coded question which relates to the column in our raw survey data  
* parent_question: The main question number for survey items with multiple selections  
* short_description: A shortened version of the survey question  
* survey_question: The actual survey question  
* question_type: The type of survey question  

### Data Exploration

To start, we'd like to see the distribution of survey responses across all survey questions. A quick and dirty way is to use the `describe` function from Hmisc package.  

We can do this on one question. 

```{r describe_q01}
describe(survey_df$Q01)
```

We can also do this for the entire dataset. 

```{r describe_all}
describe(survey_df)
```

And that takes up a lot of space. One handy way to make it more readable is to wrap in `html` and set `scroll=TRUE`. This also gives you a cool distribution next to the numeric variables. 

```{r html_scroll}
html(describe(survey_df),scroll = TRUE)
```

### dplyr  

`dplyr` is used for data manipulation and in my opinion, which I sure carries a lot of weight, is one THE MOST IMPORTANT for R-newbies to learn. It's very unlikely you will be presented with a dataset that is ready for analysis right out the gate.  

According to a survey of Machine Learning and Data Science professionals, data scientist spend on average 40% of their time on data gathering and cleaning data. Unfortunately, it's not something you will be able to avoid and `dplry` will help make this process so much easier, trust me. It's also easy to read and understand what you are doing each step in the process which is a best practice for coding.[^1] 

[^1]: [How do Data Professionals Spend their Time on Data Science Projects?](https://businessoverbroadway.com/2019/02/19/how-do-data-professionals-spend-their-time-on-data-science-projects/) ; [raw survey data](https://www.kaggle.com/kaggle/kaggle-survey-2018)  


Here are the most common data manipulation functions (_verbs_):   

* mutate() adds new variables  
* select() picks variables based on their names  
* filter() picks cases based on their values  
* summarise() reduces multiple values down to a single summary  
* arrange() changes the ordering of the rows  

We can use `n_distinct(customer_id)` in `summarise` to count the number of respondents. 

```{r summarise}

summarise(survey_df, respondent_count = n_distinct(customer_id)) 

```

This gives us the total number of observations in our dataset, `survey_df`.   

The question `Q01` represents _What is your age?_ and has the following selections:  

* 18 - 24  
* 25 - 34  
* 35 - 44 
* 45 - 49 
* 50 + 

What if we wanted to know the number of observations for each age group in `Q01`, (i.e. how many respondents selected _18 - 24_)? We can use the verb, `group_by` to split the data frame by some variable, each age group selection, and apply a function, count all the observations, to the individual data frames and then combine the output. 

The coding structure of `dplyr` is to start with the dataset you are manipulating and add a function in order of operation. So in our example we are starting with `survey_df` and then grouping by selections in `Q01` and finally counting all observations for each group. To add each function together, we use the pipe, `%>%`.  

```{r count_by_q01}
survey_df %>%
  group_by(Q01) %>%
  summarise(response_count = n_distinct(customer_id))
```

`mutate()` is handy when you want to add a new variable to the dataset. What if we wanted to know the percent selected a particular age choice? There are 501 observations in our dataset so we can just divide our count by 501.   

```{r row_count}
survey_df %>% 
  group_by(Q01) %>%
  #count the number of respondents
  summarise(response_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(response_count/501))
```

A best practice for code development is to make your process repeatable. What if the next time we did this survey we had 300 responses? We don't want to have to replace all the instances of 501 in our code with 300. What we can do instead is divide our `response_count` by the sum of each `response_count`.

```{r}
survey_df %>% 
  group_by(Q01) %>%
  #count the number of respondents
  summarise(response_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(response_count/501),
         pct_total_B = percent(response_count/sum(response_count)))
```

While we can make an educated guess as to what the survey question was for `Q01`, it's not as intuitive for the others. What's missing it our survey question which is saved in `question_df`.

```{r}
question_df %>% filter(question=='Q01')
```

The `survey_df` dataset has our questions in each column and the key to join is saved in rows in `question_df` in the `question` column. How do we join our survey data and question metadata together? Tidy to the rescue!  

#### Resources

* [Kable is a great resource to find opensource datasets](https://www.kaggle.com/datasets)  
* [Here's a dplyr cheatsheet](http://www.cs.utexas.edu/~cannata/dataVis/Class%20Notes/Week%2012/data-transformation.pdf)  
* [R Stuido has a plethora of cheat sheets avaliable](https://rstudio.com/resources/cheatsheets/)!  

## 2. Creating Tidy Data 

### Tidy Data Example

We are going to create a tidy dataset to organizing our data so that it's in a format that is easier for R to work with. A tidy dataset organizes your data such that:  

1.  Each variable in the data is in its own column    
2.  Each observation in the data is in its own row 
3.  All data is contained in a single dataset  

I like to call this tidy data "hot dog" style because the data structure is long like a hotdog bun with many rows per customer. To transform our data into a tidy dataset we will use the gather function and move all the column names into one column we will call var_name and the value in a second column we will call value. The variable new_id is our unique customer ID and we will keep this column out of the transformation.  

Here's an example of starting data in hamburger format; one row per customer:  

```{r hamburger_df}
id <- c('123', '456', '789')
sales <- c(200, 400, 500)
recency <- c(21, 100, 7)
frequency <- c(15, 20, 32)

sample_df <- data.frame(id, sales, recency, frequency)

sample_df

```

There are two main functions of data tidying: 

*  gather() which takes multiple columns and gathers them into key-value pairs  
*  spread() which takes two columns (key and value) and spreads into multiple columns  

Using gather(), we will transform our hamburger data to our hotdog, tidy, style such that we have:

*  one column, var_name, with the variable names of sales and recency
*  on column, value, with the variable value

Our customer id variable, id, is excluded from this transformation so we put a '-' in front of that variable. 

```{r hotdog_df}

sample_tidy <- sample_df %>%
  gather(var_name, value, -(id)) %>%
  arrange(id)

sample_tidy
```

Our wide, hamburger style, dataset has transformed into a narrow, hotdog style, dataset with multiple rows per customer. 

To go back to a messy dataset, we can apply `spread` to our new columns `var_name` and `value`.

```{r messy}

sample_messy <- sample_tidy %>%
  spread(var_name, value)

sample_messy
```

#### Exercise 1: Create a Survey Tidy Dataset

Using our survey dataset, `survey_df`, as a starting point, create a new dataset, `survey_tidy`, which has one column with each question, which we will name `question_col`, and a second column with the answer, which we will name `answer`. We want to exclude our customer id variable, `customer_id`, from this. Use `head(10)` to print the first 10 rows of your dataset and make sure it's as expected. 

```{r ex1}

survey_tidy <- survey_df %>%
  # The gather is saying take all of our columns and smoosh them together such that every single column header
  #      is now under one column, question, and the values in the rows are now in a second column we, answer
  # We don't want the customer_id column to be included in this transformation so we put -() around it to 
  #      tell R not to apply the gather function to this variable. 
  # This of this as a great big pivot you'd do in Excel
  gather(question, answer, -(customer_id)) 

survey_tidy %>%
  #this prints the first 10 rows
 head(10)

```

Taking our new survey tidy dataset, `survey_tidy`, create a final dataset, `survey_tidy_final`, adding the question metadata, inner joining on `question`. 

```{r final_tidy_df}
survey_tidy_final <- survey_tidy %>%
  inner_join(question_df, by=c('question'='question')) %>%
  arrange(customer_id)

survey_tidy_final %>%
  head(10)
```

Sweet! Now we have one dataset and are ready to start exploring!

#### Resources  

To learn more about tidy data you can check out these resource: 

*[Hadley Wickham's paper](http://vita.had.co.nz/papers/tidy-data.pdf)  
*[Introducing tidyr](https://blog.rstudio.com/2014/07/22/introducing-tidyr/)   
*[Chapter 12 in R for Data Science](https://r4ds.had.co.nz/tidy-data.html)  

## 3. Creating HTML tables

Now let's summarize Q01 again. To do this, we need to filter our `question` column where it equals `'Q01'`.  

```{r summarise_Q01}

survey_tidy_final %>% 
  filter(question=='Q01') %>%
  head(10)

```

Before we were grouping by a specific column, `Q01`. 

```{r }
survey_df %>%
  group_by(Q01) %>%
  summarise(response_count = n_distinct(customer_id))
```

Now the data we need is in the `answer` column.

```{r}
  
survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count)))

```

Now that the survey question is avalaible, let's add that in the`group_by`. 

```{r}
survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question, answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count)))
```

This table looks pretty nice but we can beautify it even more by using `kable` and `kableExtra`.

The `kable` function in R is part of the `knitr` package and is used in combination with an additional pakcage, `kableExtra`, to add formatting to the tables we create. If you are needing to make a nicer table for, this is a great, and simple, approach.  

We can take our summary above and pipe in `kable()` and `kable_styling()`.

```{r kable_Q01}

survey_tidy_final %>% 
  filter(question =='Q01') %>%
  group_by(survey_question, answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable() %>%
  kable_styling()
```

One of the first things we might want to change is not repeating our survey question over and over. We can use `collapse_rows` to merge those rows together. 

```{r, collapse_rows}

survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question,answer) %>%
  #count the number of observations
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable() %>%
  #set full_width = FALSE if you don't want to take up the entire space
  kable_styling(full_width = FALSE, position = "left") %>%
  #columns = which row or rows you are referencing, 
  #valign = where to align the result "middle", "top", "bottom"
  collapse_rows(columns = 1, valign = "top")

```

Let's add few final touches on our table by changing the labels in the header rows using `col.names` inside of `kable()` and adding a footer using `footnote()`. When presenting survey results, it's important to add the survey field date; the time period you were collecting results.  

```{r footnote}

  survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question,answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable(#col.names adds the column names 
  col.names = c("Survey Question",
                           "Answer",
                           "Response Count",
                           "Response Percentage")) %>%
  #set full_width = FALSE if you don't want to take up the entire space
  kable_styling(full_width = FALSE, position = 'left') %>%
  #columns = which row you want to reference, 
  #valign = where to align the result "middle", "top", "bottom"
  collapse_rows(columns = 1, valign = "top") %>%
  #add a footnote at the bottom of the chart
  footnote(general = "Survey field date 09/01/2019 - 09/15/2019") 
```

If we want to save this table, we can add `save_kable` at the end. 

A couple of notes:  

* You will be able to run this chunck, you will see the green bar on the side, but since we are saving the file and not outputing a result, you will not see the table. You need to look in the folder for a table named, Q01_Table.html   
* HTML tables have to be opened in the browser .

```{r save_table, warning=FALSE}

  survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question,answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable(#col.names adds the column names 
  col.names = c("Survey Question",
                           "Answer",
                           "Response Count",
                           "Response Percentage")) %>%
  #set full_width = FALSE if you don't want to take up the entire space
  kable_styling(full_width = FALSE, position = 'left') %>%
  #columns = which row you want to reference, 
  #valign = where to align the result "middle", "top", "bottom"
  collapse_rows(columns = 1, valign = "top") %>%
  #add a footnote at the bottom of the chart
  footnote(general = "Survey field date 09/01/2019 - 09/15/2019") %>%
  #this saves the file as Q01_Table.html
  save_kable(file = "Q01_Table.html", self_contained = T)
```

#### Exercise 2 Summarize Q06

Create an HTML table summarizing the number and percent responded to Q06, `parent_question==Q06` with the following features: 

1. Group by survey_question, short, answer  
2. Update column names for all columns  
3. Collapse the Survey Question and short description column (`columns = 1:2`)    
4. Add a foot note with the survey field dates  

```{r ex2}

survey_tidy_final %>% 
  filter(parent_question =='Q06') %>%
  group_by(survey_question, short_description, answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable(
    #col.names adds the column names
  col.names = c("Survey Question",
                "Item",
                "Answer",
                "Response Count",
                "Response Percentage")) %>%
  #set full_width = FALSE if you don't want to take up the entire space
  kable_styling(full_width = FALSE) %>%
  #columns = which row you want to reference, 
  #valign = where to align the result "middle", "top", "bottom"
  collapse_rows(columns = 1:2, valign = "top") %>%
  footnote(general = "Survey field date 09/01/2019 - 09/15/2019") 

```

### Heatmap Tables

A Likert scale is a question type that contains 5 or 7 response items and are used to understand respondents opinions, gauge levels or interested or measure satisfaction. Most often, researchers want to look at the "top 2" and "bottom 2" box percent response, where top-2-box is the sum of 4 and 5 and bottom-2-box is the sum of 1 and 2.   

Starting with our survey tidy dataset, save a new dataset, `top_box`, that creates three new variables counting the number of respondents for the following criteria:  

1. top_box: answer = 4 or 5   
2. middle: answer = 3  
3. bottom_box: answer = 1 or 2  

As this applys to just likert question types we will filter to only questions where `question_type=='likert'`. Group by `question`, `parent_question`, `survey_question`, `short_description`. 

We could create 3 different datsets one for each criteria and then join all together.   

```{r}

answer_4_and_5 <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert' & answer %in% c(4,5)) %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #count the number of observations 
  summarise(top_box = n_distinct(customer_id))

answer_3 <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert' & answer %in% c(3)) %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #count the number of observations 
  summarise(middle = n_distinct(customer_id))

answer_1_2 <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert' & answer %in% c(3)) %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #count the number of observations 
  summarise(bottom_box = n_distinct(customer_id))

top_box <- answer_4_and_5 %>%
  #joins datasets together by stacking them on top of one another 
  left_join(answer_3, by=c('question'='question', 'parent_question'='parent_question',
                           'survey_question'='survey_question', 'short_description'='short_description')) %>%
  left_join(answer_1_2, by=c('question'='question', 'parent_question'='parent_question',
                           'survey_question'='survey_question', 'short_description'='short_description'))
```

Or we could use `[ ]` in our `summarise` function to conditionally count the observations.  

```{r}

top_box <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert') %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #use [ ] to summarize for a particular condition 
  summarise(top_box=n_distinct(customer_id[answer %in% c('4','5')]),
            middle=n_distinct(customer_id[answer == '3']),
            bottom_box=n_distinct(customer_id[answer %in% c('1','2')])) %>%
  ungroup()

top_box %>%
  select(top_box, middle, bottom_box) %>%
  head(10)

```

We can also use mutate to sum across columns. Let's create a percent top box column by dividing `top_box` by the sum of `top_box`, `middle`, and `bottom_box`.

```{r mutate_sum_cols}

top_box <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert') %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #use [ ] to summarize for a particular condition 
  summarise(top_box=n_distinct(customer_id[answer %in% c('4','5')]),
            middle=n_distinct(customer_id[answer == '3']),
            bottom_box=n_distinct(customer_id[answer %in% c('1','2')])) %>%
  mutate(pct_top_box = top_box/(top_box + middle + bottom_box)) %>%
  ungroup()

 top_box %>%
   select(question, top_box, middle, bottom_box, pct_top_box) %>%
   head(10) %>%
   kable() %>%
   kable_styling()
```

A powerful aspect of `mutate` is the ability to use attributes you've created as inputs into variables. Another way to calculate the percent top_box is by calculating one variable, `total`, which is the sum of `top_box + middle + bottom_box` and use that variable when calculating the `pct_top_box`.

```{r}

top_box <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert') %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #use [ ] to summarize for a particular condition 
  summarise(top_box=n_distinct(customer_id[answer %in% c('4','5')]),
            middle=n_distinct(customer_id[answer == '3']),
            bottom_box=n_distinct(customer_id[answer %in% c('1','2')])) %>%
  #notice how we created a total count first and use this in the pct_top_box
  mutate(total = top_box + middle + bottom_box,
         #use the variable we just created, total, to calculate top box percentage
         pct_top_box = top_box/(total)) %>%
  ungroup()

 top_box %>%
   select(question, top_box, middle, bottom_box, total, pct_top_box) %>%
   head(10) %>%
   kable() %>%
   kable_styling()
 
```

#### Exercise 3: Top 2 Box Table 

Our first business question is to know what the most important features are when choosing where to shop. Output a table of the top 2 box percentage of importance ranking, `parent_question=='Q04'` and updaate the column names to "Survey Item" and "Top 2 Box Percent".   

What are the top and bottom ranked items?  

```{r ex3}

top_box %>%
  filter(parent_question=='Q04') %>% 
  select(short_description, pct_top_box) %>%
  #sort percentage from high to low
  arrange(desc(pct_top_box)) %>%
  kable(
        col.names = c("Survey Item",
                "Top 2 Box Percent")) %>%
  kable_styling()

```

`Has a great rewards/loyalty program ` is the top ranked item of importance and `Carries high quality products/brans` it bottom ranked. 

### Formating with formattable 

We can use the package `formattable` with `kable()` to spice up out table a little. 

The `color_tile()` overlays a heatmap for a specified column.  

```{r heatmap}

top_box %>%
  filter(parent_question=='Q04') %>%
  arrange(desc(pct_top_box)) %>%
  #add formattable options in the mutate statement
  mutate(
    #color_tile provides a heat maps, first color is lowest value and second is highest value
    pct_top_box = color_tile("pink", "green")(round(pct_top_box,2))) %>% 
  select(short_description, pct_top_box) %>%
  #note we need to add escape = F because the formattable produces HTML code and we want to ignore special characters
  kable(escape = F,
        col.names = c("Survey Item",
                "Top Box Percent")) %>%
  kable_styling()

```

Nice! 

_Importance:_ is repeated for all lines. Our table would look better if we excluded that word. We can use `str_replace()` to search for a pattern and replace it with a new pattern. We can look for _Importance:_ in `short_description` and replace it with a blank space. 


```{r str}

top_box %>%
  filter(parent_question=='Q04') %>%
  arrange(desc(pct_top_box)) %>%
  #add formattable options in the mutate statement
  mutate(item = str_replace(short_description, 'Importance: ', ''), #search for Importance: and replace with a blank
    #color_tile provides a heat maps, first color is lowest value and second is highest value
    pct_top_box = color_tile("pink", "green")(round(pct_top_box,2))) %>% 
  select(item, pct_top_box) %>%
  kable(escape = F,
        col.names = c("Survey Item",
                "Top Box Percent")) %>%
  kable_styling()

```

#### Exercise 4: Heatmap of Satisfication

Create a similar table for our satisficaiton question, `Q07`. Used what you've learned in the Creating HTML and data munging in creating charts above (hint: `str_replace`) to format the table.   

```{r ex4}

top_box %>%
  filter(parent_question=='Q07') %>%
  #I'm using the arrange(desc) to order from highest to lowest value
  arrange(desc(pct_top_box)) %>%
  #add formattable options in the mutate statement
  mutate(item = str_replace(short_description, 'Satisfaction: ', ''),
    #color_tile provides a heat maps, first color is lowest value and second is highest value
    pct_top_box = color_tile("pink", "green")(round(pct_top_box,2))) %>% 
  select(item, pct_top_box) %>%
  kable(escape = F,
        col.names = c("Survey Question",
                "Top Box Percent")) %>%
  kable_styling() %>%
  footnote(general = "Survey field date 09/01/2019 - 09/15/2019") 

```

##### Resource 

*Create Awesome HTML Table with knitr::kable and kableExtra)[http://haozhu233.github.io/kableExtra/awesome_table_in_html.html#overview].  


## 4. Create A Banner Output

Let's look back at our starting raw survey data. How would you go about building a summary of all questions?  
```{r}
survey_df %>%
  head(10) %>%
  kable() %>%
  kable_styling()
```

Now let's look at our tidy dataset. 

```{r}
survey_tidy_final %>%
  head(10) %>%
  kable() %>%
  kable_styling()
```

At a minimum, the data we want to summarize are in two columns, `question` and `answer`. The power of having our dataset in a tidy format is we can group by all of this at once and create one output. 

```{r banner_count}

banner_df <- survey_tidy_final %>% 
  group_by(question, answer) %>%
  #another way to calculate the response count is by counting the unique customers 
  summarise(response_count = n_distinct(customer_id)) %>%
  mutate(pct_response = percent(response_count/sum(response_count)))

banner_df %>%
    head(10) %>%
  kable() %>%
  kable_styling() 


```

Since we joined to the question metadata file, we can add `parent_question`, `survey_question`, `short_description` such that we have more information in our table. 

```{r banner_final}

banner_df <- survey_tidy_final %>% 
  group_by(parent_question, question, survey_question, short_description, answer) %>%
  #another way to calculate the response count is by counting the unique customers 
  summarise(response_count = n_distinct(customer_id)) %>%
  mutate(pct_response = percent(response_count/sum(response_count))) %>%
  ungroup()

banner_df %>%
    head(10) %>%
  kable() %>%
  kable_styling() 

```

Let's create a final HTML summary with a little formatting we could use for an internal review and an exel for our final deliverable.  

Remember running this will not produce an output. You will have two new outputs in your folder, banner_summary.html and banner_summary_total.csv.  

```{r, warning=FALSE}

banner_df %>%
  kable(#col.names adds the column names 
  col.names = c("Main Question",
                "Question Number",
                "Survey Question",
                 "Item",
                 "Answer",
                 "Response Count",
                 "Percent Response")) %>%
  kable_styling() %>%
collapse_rows(columns = 1:3, valign = "top") %>%
save_kable(file = "banner_summary.html", self_contained = T) 

write_csv(banner_df, "banner_summary_total.csv")

```

#### Banner output Tables  

Having all our data summarized in one table makes it easy to pull and create table. Let's look up the reasons for owning a cat.  

```{r}
banner_df %>%
  filter(parent_question == 'Q03') %>%
  kable() %>%
  kable_styling()
```

An easier way to read this table could be to take the rating values in the column `answer` and transpose those such that they become column headers and the `pct_response` are values in rows. We can use the `spread()` function to transform our data from wide back to messy. We will keep the survey question, description, and percent responded 1:5. 

```{r banner_messy}

banner_df %>%
  filter(parent_question == 'Q03') %>%
  #adding a - in front of a variable excludes it from the data set
  select(-parent_question, - question, -response_count) %>%
  mutate(item=str_replace(short_description, 'Reasons for owning a cat: ', "")) %>%
  select(-short_description) %>%
  #takes our hotdog dataset and transforms it to hamburger style with each rating response (1 - 5) as a separate
  # column with the percent response as values in rows 
  spread(answer, pct_response) %>%
  kable(col.names = c("Survey Question",
                "Item",
                "Extremely Unimportant (1)",
                "Not Important (2)",
                "Somewhat Important (3)",
                "Very Important (4)",
                "Extremely Important (5)"
  )) %>%
  collapse_rows(columns = 1, valign = "top") %>%
  kable_styling()
```

Now we have a table that makes it easier to compare across items. 18.56% of our respondents rated _Brings my family closer together_ as _Extremely Important_ when thinking about reasons for owning a cat.  

### Creating a Banner by Groups

Our client is interested in understanding the differences by age and likelihood to recommend (NPS), so she will probably ask for a banner view of all of these.

Using the raw survey data, let's create a new table with the `customer_id` and the following groups: 

1. Age (`Q01`)  
  *18 - 24   
  *25 - 34  
  *35 - 44  
  *45+  (45 - 49 & 50 +)  
2. Likelihood to recommend (`Q05`)  
  *Detractor: 0-6  
  *Passive: 7-8  
  *Promoter: 9-10 

To create groups we will use the `case_when` statement in dplyr (to me this is easier to read than nested if statements).   

The general structure for writing `case_when` statements is:  
`case_when`(*some condition/criteria* `~` *what happens the condition/criteria is met*)

```{r age_group}
survey_groups <- survey_df %>%
  mutate(age_group = case_when(Q01 == '18 - 24' ~ '18 - 24',
                               Q01 == '25 - 34' ~ '25 - 34',
                               Q01 == '35 - 44' ~ '35 - 44',
                               Q01 == '45 - 49' | Q01 == '50 +' ~ '45+'))

# we can do a quick summary to make sure all values are accounted
survey_groups %>% 
  group_by(age_group) %>%
  summarise(response_count = n_distinct(customer_id))
```

#### Exercise 5 - Create Groups

Add a likelihood to recommend (`nps`) and keep just our customer ID and the two columns you've created. Do a quick summary to see if you've captures all the groups.  

```{r ex5}
survey_groups <- survey_df %>%
  mutate(age_group = case_when(Q01 == '18 - 24' ~ '18 - 24',
                               Q01 == '25 - 34' ~ '25 - 34',
                               Q01 == '35 - 44' ~ '35 - 44',
                               Q01 == '45 - 49' | Q01 == '50 +' ~ '45+'),
         nps = case_when(Q05<=6 ~ 'Detractor',
                         Q05 %in% c(7,8) ~ 'Passive',
                         Q05 >=9 ~ 'Promoter'
                         )) %>%
  select(customer_id, age_group, nps)

# we can do a quick summary to make sure all values are accounted
survey_groups %>% 
  group_by(nps) %>%
  summarise(response_count = n_distinct(customer_id))
```

Now let's join our survey groups back to our tidy dataset, `survey_tidy_final`. 

```{r}

survey_tidy_groups <- survey_tidy_final %>%
  inner_join(survey_groups, by=c('customer_id' = 'customer_id'))

survey_tidy_groups %>%
  head(10) %>%
  kable() %>%
  kable_styling()
```

#### Exercise 6: Age Group Summary 

Now we are ready to create new banner summaries for our groups! Create a banner summary of JUST percent responded by age group and transform that data such that each age group is a separate column. Print the first 10 rows to make sure your table looks as expected. 

```{r ex6}

age_group_banner <- survey_tidy_groups %>% 
  group_by(age_group, question, survey_question, short_description, answer) %>%
  #count the number of instances; with one row per customer, another way to calculate the response count
  # is by counting the unique customers 
  summarise(response_count = n_distinct(customer_id)) %>%
  mutate(response_pct = response_count/sum(response_count))%>%
  select(-response_count) %>%
  #we want each age_group category in a separate column with the response_pct in rows
  spread(age_group, response_pct)

age_group_banner %>% 
  head(10) %>%
  kable() %>%
  kable_styling()
```


## Putting it all together! 

Use what you've learned and build a table to asnwer our business questions: 

1. What are the most important features when selecting where to shop?  
2. Of those items that are most important, how is Hillary preforming (what is the satisfaction rating)?  
3. Bonus: Are there any features that differ by age or nps group?  
4. Based on what you learned above, What recomendations would you give to Hillary?  

### Final Result

```{r final_exercise}

#create one dataset with top box percent of importance 
importance <- top_box %>%
  filter(parent_question=='Q04') %>% 
  mutate(item = str_replace(short_description, 'Importance: ', '')) %>%
  select(item, pct_top_box) %>%
  #sort percentage from high to low
  arrange(desc(pct_top_box)) 

#create a second dataset with top box percent of satisfication 
satisfaction <- top_box %>%
  filter(parent_question=='Q07') %>% 
  mutate(item = str_replace(short_description, 'Satisfaction: ', '')) %>%
  select(item, pct_top_box)

top_box_pct <- importance %>%
  # when removing 'Importance: ' from the short_description in our importance table and 
  # 'Satisfaction: ' from our satisfaction table, the values in the new column, item, are the same 
  # which means we can join on those values and create one table  
  inner_join(satisfaction, by=c('item'='item')) %>%
  # because the column pct_top_box is in both datasets, R adds a .x on the end
  # the column pct_top_box from our importance dataset is renames pct_top_box.x and 
  # the column pct_top_box from our importance dataset is renames pct_top_box.y and 
  # I'm renaming to make them more intuitive
  rename(importance_pct_top_box = pct_top_box.x, 
         satisfaction_pct_top_box = pct_top_box.y) %>%
  arrange(desc(importance_pct_top_box))

top_box_pct %>%
  mutate(importance_pct_top_box = color_tile("pink", "green")(round(importance_pct_top_box,2)),
         satisfaction_pct_top_box = color_tile("pink", "green")(round(satisfaction_pct_top_box,2))) %>%
  kable(escape=F,
    col.names = c("Feature",
                "Importance Top Box %",
                "Satisfaction Top Box %")) %>%
  kable_styling()


```

#### Recomendations 

~70% of customers rated `Has a great rewards/loyalty program` as Very (4) or Extremely (5) Important when choosing where to shop for their cat. Unfortunately, only ~12% are Very or Extremely satisfied with the same feature. We could consider investing in a loyalty program.  

However, that is expensive and time consuming. While Hillary is investigating loyalty program options, 4th on the list is `It's easy to find what I'm looking for` with 67% top-2-box importance and only 40% top-2-box satisfaction. Consider evaluating the layout of the store. 

## Knit! 

Now that you've pulled your report together, the last step is compiling the file. At the top of document there's a ball of yarn with `Knit` next to it. Selecting that will _knit_ all your code and outputs together in one HTML document that you can then pass on to others to review. 

**Note** this will ONLY work if you code is error free.  
