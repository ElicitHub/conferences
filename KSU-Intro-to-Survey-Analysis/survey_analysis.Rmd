---
title: "Intro To Survey Analysis"
output: html_document
---
## How to Use This Document

This is an R markdown document which creates a self-contained HTML file you can use to save your code and to create reports to share. A major benefit of R Markdowns is they are a reproducible method of your work which comes in handy for QC & testing, or if you are asked a question about your analysis 6 months after you turned it in.  

The main pieces of the Markdown files are code chunks (where you write your code) and text.  

When running our code chunks, we have a variety of options we can set:   

* `include = FALSE` prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.  
* `echo = FALS`E prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.  
* `message = FALSE` prevents messages that are generated by code from appearing in the finished file.  
* `warning = FALSE` prevents warnings that are generated by code from appearing in the finished.  
* `fig.cap = "..."` adds a caption to graphical results.  


[For text syntax, checkout this R Markdown cheatsheet](https://rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf).

**NOTE** There are exercises you need to complete first before you are able to render this file. 

# Introduction

The owner of Sassy Cat Boutique, Hillary, has noticed a decrease in transactions and sales and wonders if there are some pain points in the customer experience that's driving the decrease.  

Our research objective:  
1. Are there aspects of the customer experiences at Sassy Cat Hillary should address?  

We will address this research objective by answering the following business questions:  
1. What are the most important features when selecting where to shop?  
2. Of those items that are most important, how is Sassy Cat Boutique preforming (what is the satisfaction rating)?  

## Agenda

This tutorial is broken out into the following sections:  

1. Survey Data Prep
2. Creating Tidy Data
3. Creating HTML Tables
4. Creating a Banner Output

## 1. Survey Data Prep

### Load Survey Data

The pacman package is used as a package management tool and is used load packages.   

```{r setup, include=FALSE}

if (!require(pacman)) {
  install.packages('pacman')
}

#notice that you do not have to use install.packages()
pacman::p_load(stringr, plotly, ggplot2, ggthemes, readr, formattable, openxlsx, kableExtra, scales, tidyr, Hmisc, dplyr)

#use the percent option in the package scales
percent<-scales::percent

#raw survey data
survey_df <- read_csv('survey_results.csv')
#question metadata
question_df <- read_csv('question_metadata.csv')


```

Let's take a look at the raw survey data. 

```{r glimpse_survey}
glimpse(survey_df)
```

Typically surveys columns are coded such the survey question, _Please check all the items below that pertain to you and your cat. Have you ever..._, is represented by the question number and depending on the question type, the choice item number.  

In our survey dataset question `Q02_1`:  
  
* `Q02` represents the survey question; _Please check all the items below that pertain to you and your cat. Have you ever..._  
* and `_1` represents the item selection: _Celebrated your catâ€™s birthday and/or adoption date?_   

Our question metadata file has the survey coded question column and description. 

```{r glimpse_question}
glimpse(question_df)
```

Our question metadata file has the following columns:  

* question: The coded question which relates to the column in our raw survey data  
* parent_question: The main question number for survey items with multiple selections  
* short_description: A shortened version of the survey question  
* survey_question: The actual survey question  
* question_type: The type of survey question  

### Data Exploration

To start, we'd like to see the distribution of survey responses across all survey questions. A quick and dirty way is to use the `describe` function from Hmisc package.  

We can do this on one question. 

```{r describe_q01}
describe(survey_df$Q01)
```

We can also do this for the entire dataset. 

```{r describe_all}
describe(survey_df)
```

And that takes up a lot of space. One handy way to make it more readable is to wrap in `html`. This also gives you a cool distribution next to 

```{r html_scroll}
html(describe(survey_df))
```

### dplyr  

`dplyr` is used for data manipulation and in my opinion, which I sure carries a lot of weight, is one THE MOST IMPORTANT for R-newbies to learn. It's very unlikely you will be presented with a dataset that is  ready for analysis right out the gate.  

According to a survey of Machine Learning and Data Science professionals, data scientist spend on average 40% of their time on data gathering and cleaning data. Unfortunately, it's not something you will be able to avoid and `dplry` will help make this process so much easier, trust me. It's also easy to read and understand what you are doing each step in the process which is a best practice for coding.[^1] 

[^1]: (How do Data Professionals Spend their Time on Data Science Projects?)[https://businessoverbroadway.com/2019/02/19/how-do-data-professionals-spend-their-time-on-data-science-projects/] ; [raw survey data](https://www.kaggle.com/kaggle/kaggle-survey-2018)  


Here are the most common data manipulation functions (_verbs_):   

* mutate() adds new variables  
* select() picks variables based on their names  
* filter() picks cases based on their values  
* summarise() reduces multiple values down to a single summary  
* arrange() changes the ordering of the rows  

We can use `n_distinct(customer_id)` in `summarise` to count the number of respondents. 

```{r summarise}

summarise(survey_df, respondent_count = n_distinct(customer_id)) 

```

This gives us the total number of observations in our dataset, `survey_df`.   

The question `Q01` represents _What is your age?_ and has the following selections:  

* 18 - 24  
* 25 - 34  
* 35 - 44 
* 45 - 49 
* 50 + 

What if we wanted to know the number of observations for each age group in `Q01`, (i.e. how many respondents selected _18 - 24_)? We can use the verb, `group_by` to split the data frame by some variable, each age group selection, and apply a function, count all the observations, to the individual data frames and then combine the output. 

The coding structure of `dplyr` is to start with the dataset you are manipulating and add a function in order of operation. So in our example we are starting with `survey_df` and then grouping by selections in `Q01` and finally counting all observations for each group. To add each function together, we use the pipe, `%>%`.  

```{r count_by_q01}
survey_df %>%
  group_by(Q01) %>%
  summarise(response_count = n_distinct(customer_id))
```

There's a handy RStudio add-in that makes it easy to see what every step in a pipleine does by examingin the data at each point in the transformation. 

```{r installation, include=FALSE}
devtools::install_github("daranzolin/ViewPipeSteps")
```

Hilight the code below and select `Addins` and `View Pipe Chanin Steps`

```{r }
survey_df %>%
  group_by(Q01) %>%
  #count the number of respondents
  summarise(response_count = n_distinct(customer_id))
```

`mutate()` is handy when you want to add a new variable to the dataset. What if we wanted to know the percent selected a particular age choice? There are 501 observations in our dataset so we can just divide our count by 501.   

```{r row_count}
survey_df %>% 
  group_by(Q01) %>%
  #count the number of respondents
  summarise(response_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(response_count/501))
```

A best practice for code development is to make your process repeatable. What if the next time we did this survey we had 300 responses? We don't want to have to replace all the instances of 501 in our code with 300. What we can do instead is divide our `response_count` by the sum of each `response_count`.

```{r}
survey_df %>% 
  group_by(Q01) %>%
  #count the number of respondents
  summarise(response_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(response_count/501),
         pct_total_B = percent(response_count/sum(response_count)))
```

While we can make an educated guess as to what the survey question was for `Q01`, it's not as intuitive for the others. What's missing it our survey question which is saved in `question_df`.

```{r}
question_df %>% filter(question=='Q01')
```

The `survey_df` dataset has our questions in each column and the key to join is saved in rows in `question_df` in the `question` column. How do we join our survey data and question metadata together? Tidy to the rescue!  

#### Resources

* [Kable is a great resource to find opensource datasets](https://www.kaggle.com/datasets)  
* [Here's a dplyr cheatsheet](http://www.cs.utexas.edu/~cannata/dataVis/Class%20Notes/Week%2012/data-transformation.pdf)  
* [R Stuido has a plethora of cheat sheets avaliable](https://rstudio.com/resources/cheatsheets/)!  

## 2. Creating Tidy Data 

### Tidy Data Example

We are going to create a tidy dataset to organizing our data so that it's in a format that is easier for R to work with. A tidy dataset organizes your data such that:  

1.  Each variable in the data is in its own column    
2.  Each observation in the data is in its own row 
3.  All data is contained in a single dataset  

I like to call this tidy data "hot dog" style because the data structure is long like a hotdog bun with many rows per customer. To transform our data into a tidy dataset we will use the gather function and move all the column names into one column we will call var_name and the value in a second column we will call value. The variable new_id is our unique customer ID and we will keep this column out of the transformation.  

Here's an example of starting data in hamburger format; one row per customer:  

```{r hamburger_df}
id <- c('123', '456', '789')
sales <- c(200, 400, 500)
recency <- c(21, 100, 7)
frequency <- c(15, 20, 32)

sample_df <- data.frame(id, sales, recency, frequency)

sample_df

```

There are two main functions of data tidying: 

*  gather() which takes multiple columns and gathers them into key-value pairs  
*  spread() which takes two columns (key and value) and spreads into multiple columns  

Using gather(), we will transform our hamburger data to our hotdog, tidy, style such that we have:

*  one column, var_name, with the variable names of sales and recency
*  on column, value, with the variable value

Our customer id variable, id, is excluded from this transformation so we put a '-' in front of that variable. 

```{r hotdog_df}

sample_tidy <- sample_df %>%
  gather(var_name, value, -(id)) %>%
  arrange(id)

sample_tidy
```

Our wide, hamburger style, dataset has transformed into a narrow, hotdog style, dataset with multiple rows per customer. 

To go back to a messy dataset, we can apply `spread` to our new columns `var_name` and `value`.

```{r messy}

sample_messy <- sample_tidy %>%
  spread(var_name, value)

sample_messy
```

#### Exercise 1: Create a Survey Tidy Dataset

Using our survey dataset, `survey_df`, as a starting point, create a new dataset, `survey_tidy`, which has one column with each question, named `question`, and a second column with the answer, creatively named `answer`. We want to exclude our customer id variable, `customer_id`, from this. Use `head(10)` to print the first 10 rows of your dataset and make sure it's as expected. 

```{r ex1}


```

Taking our new survey tidy dataset, `survey_tidy`, create a final dataset, `survey_tidy_final`, adding the question metadata, inner joining on `question`. 

```{r final_tidy_df}
survey_tidy_final <- survey_tidy %>%
  inner_join(question_df, by=c('question'='question')) %>%
  arrange(customer_id)

survey_tidy_final %>%
  head(10)
```

Sweet! Now we have one dataset and are ready to start exploring!

#### Resources  

To learn more about tidy data you can check out these resource: 

*[Hadley Wickham's paper](http://vita.had.co.nz/papers/tidy-data.pdf)  
*[Introducing tidyr](https://blog.rstudio.com/2014/07/22/introducing-tidyr/)   
*[Chapter 12 in R for Data Science](https://r4ds.had.co.nz/tidy-data.html)  

## 3. Creating HTML tables

Now let's summarize Q01 again. To do this, we need to filter our `question` column where it equals `'Q01'`.  

```{r summarise_Q01}

survey_tidy_final %>% 
  filter(question=='Q01') %>%
  head(10)

```

Before we were grouping by a specific column, `Q01`. 

```{r }
survey_df %>%
  group_by(Q01) %>%
  summarise(response_count = n_distinct(customer_id))
```

Now the data we need is in the `answer` column.

```{r}
  
survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count)))

```

Now that the survey question is avalaible, let's add that in the`group_by`. 

```{r}
survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question, answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count)))
```

This table looks pretty nice but we can beautify it even more by using `kable` and `kableExtra`.

The `kable` function in R is part of the `knitr` package and is used in combination with an additional pakcage, `kableExtra`, to add formatting to the tables we create. If you are needing to make a nicer table for, this is a great, and simple, approach.  

We can take our summary above and pipe in `kable()` and `kable_styling()`.

```{r kable_Q01}

survey_tidy_final %>% 
  filter(question =='Q01') %>%
  group_by(survey_question, answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable() %>%
  kable_styling()
```

One of the first things we might want to change is not repeating our survey question over and over. We can use `collapse_rows` to merge those rows together. 

```{r, collapse_rows}

survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question,answer) %>%
  #count the number of observations
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable() %>%
  #set full_width = FALSE if you don't want to take up the entire space
  kable_styling(full_width = FALSE, position = "left") %>%
  #columns = which row or rows you are referencing, 
  #valign = where to align the result "middle", "top", "bottom"
  collapse_rows(columns = 1, valign = "top")

```

Let's add few final touches on our table by changing the labels in the header rows using `col.names` inside of `kable()` and adding a footer using `footnote()`. When presenting survey results, it's important to add the survey field date; the time period you were collecting results.  

```{r footnote}

  survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question,answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable(#col.names adds the column names 
  col.names = c("Survey Question",
                           "Answer",
                           "Response Count",
                           "Response Percentage")) %>%
  #set full_width = FALSE if you don't want to take up the entire space
  kable_styling(full_width = FALSE, position = 'left') %>%
  #columns = which row you want to reference, 
  #valign = where to align the result "middle", "top", "bottom"
  collapse_rows(columns = 1, valign = "top") %>%
  #add a footnote at the bottom of the chart
  footnote(general = "Survey field date 09/01/2019 - 09/15/2019") 
```

If we want to save this table, we can add `save_kable` at the end. Note that HTML tables have to be opened in the browser. 

```{r save_table}

  survey_tidy_final %>% 
  filter(question=='Q01') %>%
  group_by(survey_question,answer) %>%
  #count the number of responses
  summarise(row_count = n_distinct(customer_id)) %>%
  #calculate the percent of total
  mutate(pct_total = percent(row_count/sum(row_count))) %>%
  kable(#col.names adds the column names 
  col.names = c("Survey Question",
                           "Answer",
                           "Response Count",
                           "Response Percentage")) %>%
  #set full_width = FALSE if you don't want to take up the entire space
  kable_styling(full_width = FALSE, position = 'left') %>%
  #columns = which row you want to reference, 
  #valign = where to align the result "middle", "top", "bottom"
  collapse_rows(columns = 1, valign = "top") %>%
  #add a footnote at the bottom of the chart
  footnote(general = "Survey field date 09/01/2019 - 09/15/2019") %>%
  save_kable(file = "Q01_Table.html", self_contained = T)
```

#### Exercise 2 Summarize Q06

Create an HTML table summarizing the number and percent responded to Q06, `parent_question==Q06` with the following features: 

1. Group by survey_question, short, answer  
2. Update column names for all columns  
3. Collapse the Survey Question and short description column (`columns = 1:2`)    
4. Add a foot note with the survey field dates  

```{r ex2}



```

### Heatmap Tables

A Likert scale is a question type that contains 5 or 7 response items and are used to understand respondents opinions, gauge levels or interested or measure satisfaction. Most often, researchers want to look at the "top 2" and "bottom 2" box percent response, where top-2-box is the sum of 4 and 5 and bottom-2-box is the sum of 1 and 2.   

Starting with our survey tidy dataset, save a new dataset, `top_box`, that creates three new variables counting the number of respondents for the following criteria:  

1. top_box: answer = 4 or 5   
2. middle: answer = 3  
3. bottom_box: answer = 1 or 2  

As this applys to just likert question types we will filter to only questions where `question_type=='likert'`. Group by `question`, `parent_question`, `survey_question`, `short_description`. 

We could create 3 different datsets one for each criteria and then join all together.   

```{r}

answer_4_and_5 <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert' & answer %in% c(4,5)) %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #count the number of observations 
  summarise(top_box = n_distinct(customer_id))

answer_3 <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert' & answer %in% c(3)) %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #count the number of observations 
  summarise(middle = n_distinct(customer_id))

answer_1_2 <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert' & answer %in% c(3)) %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #count the number of observations 
  summarise(bottom_box = n_distinct(customer_id))

top_box <- answer_4_and_5 %>%
  #joins datasets together by stacking them on top of one another 
  left_join(answer_3, by=c('question'='question', 'parent_question'='parent_question',
                           'survey_question'='survey_question', 'short_description'='short_description')) %>%
  left_join(answer_1_2, by=c('question'='question', 'parent_question'='parent_question',
                           'survey_question'='survey_question', 'short_description'='short_description'))
```

Or we could use `[ ]` in our `summarise` function to conditionally count the observations.  

```{r}

top_box <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert') %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #use [ ] to summarize for a particular condition 
  summarise(top_box=n_distinct(customer_id[answer %in% c('4','5')]),
            middle=n_distinct(customer_id[answer == '3']),
            bottom_box=n_distinct(customer_id[answer %in% c('1','2')])) %>%
  ungroup()

top_box %>%
  select(top_box, middle, bottom_box) %>%
  head(10)

```

We can also use mutate to sum across columns. Let's create a percent top box column by dividing `top_box` by the sum of `top_box`, `middle`, and `bottom_box`.

```{r mutate_sum_cols}

top_box <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert') %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #use [ ] to summarize for a particular condition 
  summarise(top_box=n_distinct(customer_id[answer %in% c('4','5')]),
            middle=n_distinct(customer_id[answer == '3']),
            bottom_box=n_distinct(customer_id[answer %in% c('1','2')])) %>%
  mutate(pct_top_box = top_box/(top_box + middle + bottom_box)) %>%
  ungroup()

 top_box %>%
   select(question, top_box, middle, bottom_box, pct_top_box) %>%
   head(10) %>%
   kable() %>%
   kable_styling()
```

A powerful aspect of `mutate` is the ability to use attributes you've created as inputs into variables. 

```{r}

top_box <- survey_tidy_final %>%
  #include only likert questions
  filter(question_type=='likert') %>%
  group_by(question, parent_question, survey_question, short_description) %>%
  #use [ ] to summarize for a particular condition 
  summarise(top_box=n_distinct(customer_id[answer %in% c('4','5')]),
            middle=n_distinct(customer_id[answer == '3']),
            bottom_box=n_distinct(customer_id[answer %in% c('1','2')])) %>%
  #notice how we created a total count first and use this in the pct_top_box
  mutate(total = top_box + middle + bottom_box,
         pct_top_box = top_box/(total)) %>%
  ungroup()

 top_box %>%
   select(question, top_box, middle, bottom_box, total, pct_top_box) %>%
   head(10) %>%
   kable() %>%
   kable_styling()
 
```

#### Exercise 3: Top 2 Box Table 

Our first business question is to know what the most important features are when choosing where to shop. Output a table of the top 2 box percentage of importance ranking, `parent_question=='Q04'` and updaate the column names to "Survey Item" and "Top 2 Box Percent".   

What are the top and bottom ranked items?  

```{r ex3}



```

`Has a great rewards/loyalty program ` is the top ranked item of importance and `Carries high quality products/brans` it bottom ranked. 

### Formating with formattable 

We can use the package `formattable` with `kable()` to spice up out table a little. 

The `color_tile()` overlays a heatmap for a specified column.  

```{r heatmap}

top_box %>%
  filter(parent_question=='Q04') %>%
  arrange(desc(pct_top_box)) %>%
  #add formattable options in the mutate statement
  mutate(
    #color_tile provides a heat maps, first color is lowest value and second is highest value
    pct_top_box = color_tile("pink", "green")(round(pct_top_box,2))) %>% 
  select(short_description, pct_top_box) %>%
  kable(escape = F,
        col.names = c("Survey Item",
                "Top Box Percent")) %>%
  kable_styling()

```

Nice! 

_Importance:_ is repeated for all lines. Our table would look better if we excluded that word. We can use `str_replace()` to search for a pattern and replace it with a new pattern. We can look for _Importance:_ in `short_description` and replace it with a blank space. 


```{r str}

top_box %>%
  filter(parent_question=='Q04') %>%
  arrange(desc(pct_top_box)) %>%
  #add formattable options in the mutate statement
  mutate(item = str_replace(short_description, 'Importance: ', ''), #search for Importance: and replace with a blank
    #color_tile provides a heat maps, first color is lowest value and second is highest value
    pct_top_box = color_tile("pink", "green")(round(pct_top_box,2))) %>% 
  select(item, pct_top_box) %>%
  kable(escape = F,
        col.names = c("Survey Item",
                "Top Box Percent")) %>%
  kable_styling()

```

#### Exercise 4: Heatmap of Satisfication

Create a similar table for our satisficaiton question, `Q07`. Used what you've learned in the Creating HTML and data munging in creating charts above (hint: `str_replace`) to format the table.   

```{r ex4}



```

##### Resource 

*Create Awesome HTML Table with knitr::kable and kableExtra)[http://haozhu233.github.io/kableExtra/awesome_table_in_html.html#overview].  


## 4. Create A Banner Output

Let's look back at our starting raw survey data. How would you go about building a summary of all questions?  
```{r}
survey_df %>%
  head(10) %>%
  kable() %>%
  kable_styling()
```

Now let's look at our tidy dataset. 

```{r}
survey_tidy_final %>%
  head(10) %>%
  kable() %>%
  kable_styling()
```

At a minimum, the data we want to summarize are in two columns, `question` and `answer`. The power of having our dataset in a tidy format is we can group by all of this at once and create one output. 

```{r banner_count}

banner_df <- survey_tidy_final %>% 
  group_by(question, answer) %>%
  #another way to calculate the response count is by counting the unique customers 
  summarise(response_count = n_distinct(customer_id)) %>%
  mutate(pct_response = percent(response_count/sum(response_count)))

banner_df %>%
    head(10) %>%
  kable() %>%
  kable_styling() 


```

Since we joined to the question metadata file, we can add `parent_question`, `survey_question`, `short_description` such that we have more information in our table. 

```{r banner_final}

banner_df <- survey_tidy_final %>% 
  group_by(parent_question, question, survey_question, short_description, answer) %>%
  #another way to calculate the response count is by counting the unique customers 
  summarise(response_count = n_distinct(customer_id)) %>%
  mutate(pct_response = percent(response_count/sum(response_count))) %>%
  ungroup()

banner_df %>%
    head(10) %>%
  kable() %>%
  kable_styling() 

```

Let's create a final HTML summary with a little formatting we could use for an internal review and an exel for our final deliverable. 

```{r}

banner_df %>%
  kable(#col.names adds the column names 
  col.names = c("Main Question",
                "Question Number",
                "Survey Question",
                 "Item",
                 "Answer",
                 "Response Count",
                 "Percent Response")) %>%
  kable_styling() %>%
collapse_rows(columns = 1:3, valign = "top") %>%
save_kable(file = "banner_summary.html", self_contained = T) 

write_csv(banner_df, "banner_summary_total.csv")

```

#### Exercise 5: Banner output Tables  

Having all our data summarized in one table makes it easy to pull and create table. Create a formatted HTML table of the distribution of Reasons for owning a cat, `parent_question == 'Q03'` using our new banner table, `banner_df` such that the columns are the importance ranking percent selected. Keep the survey question, description, and percent responded 1:5. Your table should have 7 total columns. 

```{r ex5}

```

### Creating a Banner by Groups

Our client is interested in understanding the differences by age and likelihood to recommend (NPS), so she will probably ask for a banner view of all of these.

Using the raw survey data, let's create a new table with the `customer_id` and the following groups: 

1. Age (`Q01`)  
  *18 - 24   
  *25 - 34  
  *35 - 44  
  *45+  (45 - 49 & 50 +)  
2. Likelihood to recommend (`Q05`)  
  *Detractor: 0-6  
  *Passive: 7-8  
  *Promoter: 9-10 

To create groups we will use the `case_when` statement in dplyr (to me this is easier to read than nested if statements).   

The general structure for writing `case_when` statements is:  
`case_when`(*some condition/criteria* `~` *what happens the condition/criteria is met*)

```{r age_group}
survey_groups <- survey_df %>%
  mutate(age_group = case_when(Q01 == '18 - 24' ~ '18 - 24',
                               Q01 == '25 - 34' ~ '25 - 34',
                               Q01 == '35 - 44' ~ '35 - 44',
                               Q01 == '45 - 49' | Q01 == '50 +' ~ '45+'))

# we can do a quick summary to make sure all values are accounted
survey_groups %>% 
  group_by(age_group) %>%
  summarise(response_count = n_distinct(customer_id))
```

#### Exercise 6 - Create Groups

Add a likelihood to recommend (`nps`) and keep just our customer ID and the two columns you've created. Do a quick summary to see if you've captures all the groups.  

```{r ex6}

```

Now let's join our survey groups back to our tidy dataset, `survey_tidy_final`. 

```{r}

survey_tidy_groups <- survey_tidy_final %>%
  inner_join(survey_groups, by=c('customer_id' = 'customer_id'))

survey_tidy_groups %>%
  head(10) %>%
  kable() %>%
  kable_styling()
```

#### Exercise 7: Age Group Summary 

Now we are ready to create new banner summaries for our groups! Create a banner summary of JUST percent responded by age group and transform that data such that each age group is a separate column. Print the first 10 rows to make sure your table looks as expected. 

```{r ex7}


```


## Putting it all together! 

Use what you've learned and build a table to asnwer our business questions: 

1. What are the most important features when selecting where to shop?  
2. Of those items that are most important, how is Hillary preforming (what is the satisfaction rating)?  
3. Bonus: Are there any features that differ by age or nps group?  
4. Based on what you learned above, What recomendations would you give to Hillary?  

### Final Result

```{r final_exercise}


```

~70% of customers rated `Has a great rewards/loyalty program` as Very (4) or Extremely (5) Important when choosing where to shop for their cat. Unfortunately, only ~12% are Very or Extremely satisfied with the same feature. We could consider investing in a loyalty program. 

However, that is expensive and time consuming. While Hillary is investigating loyalty program options, second on the list is `It's easy to find what I'm looking for` with 67% top-2-box importance and only 40% top-2-box satisfaction. Consider evaluating the layout of the store.
